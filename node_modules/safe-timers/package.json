{
  "_args": [
    [
      {
        "raw": "safe-timers@^1.0.1",
        "scope": null,
        "escapedName": "safe-timers",
        "name": "safe-timers",
        "rawSpec": "^1.0.1",
        "spec": ">=1.0.1 <2.0.0",
        "type": "range"
      },
      "/Applications/邓肯21/FE/egg-example/node_modules/egg-schedule"
    ]
  ],
  "_cnpm_publish_time": 1465985087935,
  "_from": "safe-timers@^1.0.1",
  "_hasShrinkwrap": false,
  "_id": "safe-timers@1.0.1",
  "_location": "/safe-timers",
  "_nodeVersion": "4.2.2",
  "_npmOperationalInternal": {
    "host": "packages-12-west.internal.npmjs.com",
    "tmp": "tmp/safe-timers-1.0.1.tgz_1465985087246_0.6410285013262182"
  },
  "_npmUser": {
    "name": "ronkorving",
    "email": "ron@ronkorving.nl"
  },
  "_npmVersion": "2.14.7",
  "_phantomChildren": {},
  "_requested": {
    "raw": "safe-timers@^1.0.1",
    "scope": null,
    "escapedName": "safe-timers",
    "name": "safe-timers",
    "rawSpec": "^1.0.1",
    "spec": ">=1.0.1 <2.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/egg-schedule"
  ],
  "_resolved": "http://registry.npm.taobao.org/safe-timers/download/safe-timers-1.0.1.tgz",
  "_shasum": "e34549f3f77de522efd5d6ef7f2974688979b0c8",
  "_shrinkwrap": null,
  "_spec": "safe-timers@^1.0.1",
  "_where": "/Applications/邓肯21/FE/egg-example/node_modules/egg-schedule",
  "author": {
    "name": "Ron Korving",
    "email": "rkorving@wizcorp.jp"
  },
  "bugs": {
    "url": "https://github.com/Wizcorp/safe-timers/issues"
  },
  "dependencies": {},
  "description": "Timers with near-infinite duration support",
  "devDependencies": {
    "tap-spec": "^4.1.1",
    "tape": "^4.5.1"
  },
  "directories": {
    "test": "test"
  },
  "dist": {
    "shasum": "e34549f3f77de522efd5d6ef7f2974688979b0c8",
    "size": 3652,
    "noattachment": false,
    "tarball": "http://registry.npm.taobao.org/safe-timers/download/safe-timers-1.0.1.tgz"
  },
  "gitHead": "7972f81a1b3d69eb89f33f7c61a441de0765c7c3",
  "homepage": "https://github.com/Wizcorp/safe-timers#readme",
  "keywords": [
    "setTimeout",
    "setInterval",
    "timer",
    "interval",
    "timers",
    "intervals"
  ],
  "license": "MIT",
  "main": "index.js",
  "maintainers": [
    {
      "name": "ronkorving",
      "email": "ron@ronkorving.nl"
    },
    {
      "name": "wizcorp",
      "email": "npm@wizcorp.jp"
    }
  ],
  "name": "safe-timers",
  "optionalDependencies": {},
  "publish_time": 1465985087935,
  "readme": "# Safe Timers\n\n## About\n\nQ: What's this all about? Aren't JavaScript timers safe?\nA: Long story short: they're a bit broken. This module unbreaks them.\n\nWhether it's by spec, or by accident, **all** major browsers and Node.js limit the interval a setTimeout can accept to a\n32 bit signed integer. What that means in essence is that a timeout can never last longer than 24.85 days. Long enough,\nright?\n\nThe problem is that:\n\n- In human (non-binary) terms, this is a really arbitrary number.\n- In long running processes (whether on the web, or in Node), you are limited.\n- If the interval you provide overflows this limit, **the timer fires immediately**!\n\nAll the arguments about \"you shouldn't need intervals this big anyway\" go out the window the moment you provide a big\none and instead of never firing, it fires immediately. This is a real problem. And so here we are, Safe Timers solves\nthis for you.\n\nDoes that mean you should forego the browser native setTimeout and setInterval altogether? Absolutely not. Most of the\ntime, we pass constant short intervals, in which case Safe Timers are overkill. But when your interval comes from some\nvariable that depends on state or user input, using Safe Timers is a good idea.\n\n## API\n\n**Timer setTimeout(Function callback, number interval, mixed arg1, mixed arg2, ...)**\n\nCalls `callback` after at least `interval` milliseconds have passed. All arguments passed after the `interval` will be\npassed to the callback once it gets invoked. Returns a `Timer` instance.\n\n```js\nconst setTimeout = require('safetimers').setTimeout;\n\nsetTimeout(function (msg) {\n  console.log(msg);\n}, 5000, 'Hello world');\n```\n\n**Timer setTimeoutAt(Function callback, number timestamp, mixed arg1, mixed arg2, ...)**\n\nCalls `callback` when our clock reaches the given `timestamp` (in milliseconds). All arguments passed after the\n`interval` will be passed to the callback once it gets invoked. Returns a `Timer` instance.\n\n```js\nconst setTimeoutAt = require('safetimers').setTimeoutAt;\n\nsetTimeoutAt(function (msg) {\n  console.log(msg);\n}, Date.now() + 5000, 'Hello world');\n```\n\n**Interval setInterval(Function callback, number interval, mixed arg1, mixed arg2, ...)**\n\nCalls `callback` after at least every `interval` milliseconds. All arguments passed after the `interval` will be passed\nto the callback when it gets invoked. Returns an `Interval` instance.\n\n```js\nconst setInterval = require('safetimers').setInterval;\n\nsetInterval(function (msg) {\n  console.log(msg);\n}, 5000, 'Hello world');\n```\n\n**timer.clear() / interval.clear()**\n\nThe response from `safetimers.setTimeout[At]` and `safetimers.setInterval` are `Timer` and `Interval` objects\nrespectively. To cancel a timer or interval, you can call `clear` on it.\n\n```js\nconst setTimeout = require('safetimers').setTimeout;\n\nconst timer = setTimeout(function (msg) {\n  console.log(msg); // this will never show\n}, 5000, 'Hello world');\n\ntimer.clear();\n```\n",
  "readmeFilename": "ReadMe.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/Wizcorp/safe-timers.git"
  },
  "scripts": {
    "test": "tape test/*.js | tap-spec"
  },
  "version": "1.0.1"
}
